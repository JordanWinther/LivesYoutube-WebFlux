# LivesYoutube-WebFlux

Considerando uma aplicação que utiliza programação síncrona e bloqueante como Spring MVC, quando um determinado cliente envia uma requisição para o servidor, supondo que seja uma requisição que solicita um grande volume de dados por exemplo, o processamento levará mais tempo até que o cliente receba de volta essa resposta. E se o cliente, em seguida, enviar mais duas requisições posteriores ao servidor, Requisição 2 e Requisição 3, essas ficarão bloqueadas até que a Requisição 1 seja finalizada. Ou seja, gera-se um gargalo na aplicação em casos de processamentos longos. Ao término do processamento da Requisição 1, a Requisição 2 será processada e da mesma maneira, ao término do processamento da Requisição 2, a Requisição 3 será processada. Quando o módulo Spring MVC é utilizado para construir aplicações web, o processamento é dessa maneira, síncrono e bloqueante.

Agora, considerando uma aplicação assíncrona e não bloqueante, ou seja, dados podem chegar em tempo real e serem processados, se o mesmo cliente do exemplo anterior enviar ao servidor a mesma Requisição 1, solicitando um grande volume de dados e em seguida, enviar mais duas Requisições, 2 e 3, a Requisição 1 não mais bloqueará as requisições que forem chegando posteriores a ela. Isso porque como a aplicação é não bloqueante, as requisições podem ser processadas de forma paralela, não criando bloqueios e nem gargalos na aplicação. Quando o módulo Spring Webflux é utilizado para construir aplicações web, o processamento neste caso é assíncrono e não bloqueante.
